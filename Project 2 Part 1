Project 2 Part 1

Our journey starts with the line of code:
int fd;
close(fd);

usys.S:4-8
4	#define SYSCALL(name) \
5	  .globl name; \
6	  name: \
7	    movl $SYS_ ## name, %eax; \
8	    int $T_SYSCALL; \

The first lines of code run are the macro defined assembly function name.  The function name pushes the macro value SYS_close (syscall.h:22) into register eax before triggering an interrupt with a syscall trap T_SYSCALL (traps.h:27).  This interrupt triggers the interrupt handling mechanisms.  

vectors.S:318-321
318	vector64:                                                                                                     
319	   319   pushl $0                                                                                                    
320	   320   pushl $64                                                                                                   
321	   321   jmp alltraps 

trapasm.S:5-20
4	.globl alltraps
5	alltraps:
6	  # Build trap frame.
7	  pushl %ds
8	  pushl %es
9	  pushl %fs
10	  pushl %gs
11	  pushal
12	  
13	  # Set up data segments.
14	  movw $(SEG_KDATA<<3), %ax
15	  movw %ax, %ds
16	  movw %ax, %es
17
18	  # Call trap(tf), where tf=%esp
19	  pushl %esp
20	  call trap

First this goes to vectors.S, the trap entry point.  It pushes the interrupt number onto the stack, and then calls alltraps.  Alltraps sets up the trap frame by pushing registers to the stack and then calls trap with the new trapframe as an argument.

trap.c:36-43
36	void
37	trap(struct trapframe *tf)
38	{
39	  if(tf->trapno == T_SYSCALL){
40	    if(myproc()->killed)
41	      exit();
42	    myproc()->tf = tf;
43	    syscall();

syscall.c:86-140
	...
86	extern int sys_close(void);
	...

108	static int (*syscalls[])(void) = {
	...
129	[SYS_close]   sys_close,
	...
130	};

132	void
133	syscall(void)
134	{
135	  int num;
136	  struct proc *curproc = myproc();
137
138	  num = curproc->tf->eax;
139	  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
140	    curproc->tf->eax = syscalls[num]();

Called from alltraps, trap sees that its interrupt is from a system call, and passes control to the syscall function.  Syscall pulls the system call number from %eax, set way back in usys.S, in our case SYS_close, i.e. 21.  It then sets %eax to the return value of syscalls[num]() which in turn is that of sys_close() from the list of function pointers syscalls[]().

sysfile.c:93-99
93	int
94	sys_close(void)
95	{
96	  int fd;
97	  struct file *f;
98
99	  if(argfd(0, &fd, &f) < 0)

sysfile.c:22-27
21	static int
22	argfd(int n, int *pfd, struct file **pf)
23	{
24	  int fd;
25	  struct file *f;
26
27	  if(argint(n, &fd) < 0)

syscall.c:49-52
49	int
50	argint(int n, int *ip)
51	{
52	  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);

syscall.c:17-23
17	int
18	fetchint(uint addr, int *ip)
19	{
20	  struct proc *curproc = myproc();
21
22	  if(addr >= curproc->sz || addr+4 > curproc->sz)
23	    return -1;
24	  *ip = *(int*)(addr);
25	  return 0;
26	}

sysfile.c:29-30
29	if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0) 
30	    return -1;											   

syscall.c:140
140		curproc->tf->eax = syscalls[num]();


Sysfile.c is the home of sys_close(), which first tries to get the file descriptor close was called on in userspace by calling argfd.  Argfd in turn calls argint which attempts to pull the first integer argument from the stack via a direct call to fetchint.  This will grab a bad file descriptor and pass it back to argfd via argint.  Argfd then sees that fd does not refer to a valid file and returns -1 to sys_close().  Sys_close then returns this -1 as well which syscall stores in %eax.

trap.c:44-47
44	    if(myproc()->killed)
45	      exit();
46	    return;
47	  }

trapasm.S:21-32
21	  addl $4, %esp
22
23	  # Return falls through to trapret...
24	.globl trapret
25	trapret:
26	  popal
27	  popl %gs
28	  popl %fs
29	  popl %es
30	  popl %ds
31	  addl $0x8, %esp  # trapno and errcode
32	  iret

usys.S:9
9	    ret


Syscall falls through to the rest of trap.c, but with the syscall return value stored in %eax.  This then returns to trapasm and falls through to trapret, which pops the registers placed on the stack by alltraps back into the appropriate register.  Then it calls iret, a return funciton that also changes the permissions back from kernel to user.  Usys then returns back to the function that originally called the system call.











